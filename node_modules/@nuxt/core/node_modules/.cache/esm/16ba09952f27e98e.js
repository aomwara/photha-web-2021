let readFileSync,parse,traverse,parseComponent,formatMessage,COMPONENT_OPTIONS_KEY;_2f2‍.x([["extractComponentOptions",()=>extractComponentOptions]]);_2f2‍.w("fs",[["readFileSync",["readFileSync"],function(v){readFileSync=v}]]);_2f2‍.w("@babel/parser",[["parse",["parse"],function(v){parse=v}]]);_2f2‍.w("@babel/traverse",[["default",["traverse"],function(v){traverse=v}]]);_2f2‍.w("vue-template-compiler",[["parseComponent",["parseComponent"],function(v){parseComponent=v}]]);_2f2‍.w("../templates/utils-common",[["formatMessage",["formatMessage"],function(v){formatMessage=v}]]);_2f2‍.w("./constants",[["COMPONENT_OPTIONS_KEY",["COMPONENT_OPTIONS_KEY"],function(v){COMPONENT_OPTIONS_KEY=v}]]);


// Must not be an explicit dependency to avoid version mismatch issue.
// See https://github.com/nuxt-community/i18n-module/issues/297




/**
 * Extracts nuxtI18n component options for given component file path.
 *
 * @typedef {Required<Pick<import('../../types/vue').NuxtI18nComponentOptions, 'locales' | 'paths'>>} ComputedPageOptions
 *
 * @param {import('@nuxt/types/config/router').NuxtRouteConfig['component']} component
 * @return {ComputedPageOptions | false}
 */
       function extractComponentOptions (component) {
  if (typeof (component) !== 'string') {
    return false
  }

  /** @type {ComputedPageOptions | false} */
  let componentOptions = {
    locales: [],
    paths: {}
  }

  let contents
  try {
    contents = readFileSync(component).toString()
  } catch (error) {
    _2f2‍.g.console.warn(formatMessage(`Couldn't read page component file (${error.message})`))
  }

  if (!contents) {
    return componentOptions
  }

  const Component = parseComponent(contents)

  if (!Component.script || Component.script.content.length < 1) {
    return componentOptions
  }

  const script = Component.script.content

  try {
    const parsed = parse(script, {
      sourceType: 'module',
      plugins: [
        'nullishCoalescingOperator',
        'optionalChaining',
        'classProperties',
        'decorators-legacy',
        'dynamicImport',
        'estree',
        'exportDefaultFrom',
        'typescript'
      ]
    })

    traverse(parsed, {
      enter (path) {
        // @ts-ignore
        if (path.node.type === 'Property') {
          // @ts-ignore
          if (path.node.key.name === COMPONENT_OPTIONS_KEY) {
            // @ts-ignore
            const data = script.substring(path.node.start, path.node.end)
            componentOptions = Function(`return ({${data}})`)()[COMPONENT_OPTIONS_KEY] // eslint-disable-line
          }
        }
      }
    })
  } catch (error) {
    // eslint-disable-next-line no-console
    _2f2‍.g.console.warn(formatMessage(`Error parsing "${COMPONENT_OPTIONS_KEY}" component option in file "${component}"`))
  }

  return componentOptions
}
